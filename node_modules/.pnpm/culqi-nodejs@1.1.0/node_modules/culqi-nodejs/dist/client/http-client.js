"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = exports.CulqiError = void 0;
// Ideally injected from package.json at build time
const SDK_VERSION = '0.0.1';
class CulqiError extends Error {
    status;
    data;
    constructor(message, status, data) {
        super(message);
        this.status = status;
        this.data = data;
        this.name = 'CulqiError';
    }
}
exports.CulqiError = CulqiError;
class HttpClient {
    opts;
    constructor(opts) {
        this.opts = opts;
    }
    /* -------------------------- Public facade (Axiosâ€‘like) -------------------------- */
    get(url, cfg = {}) {
        return this.request('GET', url, cfg);
    }
    post(url, cfg) {
        return this.request('POST', url, cfg);
    }
    patch(url, cfg) {
        return this.request('PATCH', url, cfg);
    }
    del(url, cfg = {}) {
        return this.request('DELETE', url, cfg);
    }
    /* ------------------------------ Internals --------------------------------- */
    headers(pub, extra) {
        return {
            'Content-Type': 'application/json',
            'User-Agent': `CulqiNodeSDK/${SDK_VERSION}`,
            Authorization: `Bearer ${pub ? this.opts.publicKey : this.opts.secretKey}`,
            ...extra,
        };
    }
    /** Serialize query parameters */
    static serialize(params) {
        if (!params || Object.keys(params).length === 0)
            return '';
        const qs = new URLSearchParams();
        for (const [k, v] of Object.entries(params)) {
            if (v !== undefined && v !== null)
                qs.append(k, String(v));
        }
        const s = qs.toString();
        return s ? `?${s}` : '';
    }
    async request(method, path, cfg) {
        const { params, data, headers: extraHeaders, pub = false, timeout = this.opts.timeout ?? 8000, retries = this.opts.retries ?? 2, } = cfg;
        const url = `${this.opts.baseUrl ?? 'https://api.culqi.com'}${path}${HttpClient.serialize(params)}`;
        const headers = this.headers(pub, extraHeaders);
        let attempt = 0;
        while (attempt <= retries) {
            const res = await fetch(url, {
                method,
                headers,
                body: data ? JSON.stringify(data) : undefined,
                // @ts-expect-error Node fetch typings lack timeout
                timeout,
            });
            if (res.ok) {
                return (await res.json().catch(() => undefined));
            }
            if (attempt === retries) {
                const errJson = await res.json().catch(() => undefined);
                throw new CulqiError(
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                errJson?.merchant_message || res.statusText, res.status, errJson);
            }
            attempt++;
        }
        /* istanbul ignore next */
        throw new CulqiError('Retry overflow', 500, undefined);
    }
}
exports.HttpClient = HttpClient;
//# sourceMappingURL=http-client.js.map